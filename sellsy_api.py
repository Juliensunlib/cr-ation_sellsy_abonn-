import os
import json
import time
import requests
import logging
from typing import Dict, List, Optional
from datetime import datetime, timedelta

class SellsyAPI:
    """
    Client API pour Sellsy v2 bas√© sur l'authentification OAuth 2.0.
    """
    
    # URL de l'API v2
    API_BASE_URL = "https://api.sellsy.com/v2"
    # URL correcte pour l'authentification OAuth2 de Sellsy v2
    AUTH_URL = "https://api.sellsy.com/oauth2/access-token"
    
    def __init__(self, client_id, client_secret, access_token=None, refresh_token=None, logger=None):
        """
        Initialise le client API Sellsy v2.
        
        Args:
            client_id: Identifiant client OAuth 2.0
            client_secret: Secret client OAuth 2.0
            access_token: Token d'acc√®s (optionnel)
            refresh_token: Token de rafra√Æchissement (optionnel)
            logger: Logger pour journaliser les actions
        """
        self.client_id = client_id
        self.client_secret = client_secret
        self.access_token = access_token
        self.refresh_token = refresh_token
        self.token_expires_at = None
        
        # D√©finir un logger par d√©faut si aucun n'est fourni
        if logger is None:
            self.logger = logging.getLogger('SellsyAPI')
            handler = logging.StreamHandler()
            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            handler.setFormatter(formatter)
            self.logger.addHandler(handler)
            self.logger.setLevel(logging.INFO)
        else:
            self.logger = logger
        
        self.logger.debug("SellsyAPI v2 initialis√©e avec succ√®s")
    
    def _get_auth_header(self) -> Dict:
        """
        Obtient l'en-t√™te d'authentification pour les requ√™tes API.
        
        Returns:
            En-t√™te d'authentification
        """
        if self._is_token_expired():
            self.refresh_access_token()
            
        return {"Authorization": f"Bearer {self.access_token}"}
    
    def _is_token_expired(self) -> bool:
        """
        V√©rifie si le token d'acc√®s est expir√©.
        
        Returns:
            True si le token est expir√© ou non d√©fini, False sinon
        """
        if not self.access_token or not self.token_expires_at:
            return True
            
        return datetime.now() >= self.token_expires_at
    
    def get_access_token(self) -> bool:
        """
        Obtient un nouveau token d'acc√®s en utilisant le flux d'authentification client credentials.
        
        Returns:
            True si l'obtention du token a r√©ussi, False sinon
        """
        try:
            self.logger.info("üîÑ Obtention d'un nouveau token d'acc√®s...")
            
            # En-t√™tes pour l'authentification Basic
            auth = (self.client_id, self.client_secret)
            
            # Param√®tres de la requ√™te
            payload = {
                "grant_type": "client_credentials"
            }
            
            # En-t√™tes pour sp√©cifier le type de contenu
            headers = {
                "Content-Type": "application/x-www-form-urlencoded"
            }
            
            response = requests.post(
                self.AUTH_URL, 
                auth=auth,
                data=payload,
                headers=headers
            )
            
            if response.status_code == 200:
                data = response.json()
                self.access_token = data["access_token"]
                # Le refresh token est g√©n√©ralement fourni avec le grant_type=authorization_code
                if "refresh_token" in data:
                    self.refresh_token = data["refresh_token"]
                # Calcul de la date d'expiration (g√©n√©ralement 3600 secondes)
                expires_in = data.get("expires_in", 3600)
                self.token_expires_at = datetime.now() + timedelta(seconds=expires_in - 60)  # -60 pour marge de s√©curit√©
                
                self.logger.info(f"‚úÖ Token d'acc√®s obtenu avec succ√®s (expire dans {expires_in} secondes)")
                return True
            else:
                self.logger.error(f"‚ùå √âchec d'obtention du token: {response.status_code}")
                self.logger.error(f"D√©tails: {response.text}")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Erreur lors de l'obtention du token: {str(e)}")
            return False
    
    def refresh_access_token(self) -> bool:
        """
        Rafra√Æchit le token d'acc√®s en utilisant le token de rafra√Æchissement.
        
        Returns:
            True si le rafra√Æchissement a r√©ussi, False sinon
        """
        if self.refresh_token:
            try:
                self.logger.info("üîÑ Rafra√Æchissement du token d'acc√®s...")
                
                auth = (self.client_id, self.client_secret)
                
                payload = {
                    "grant_type": "refresh_token",
                    "refresh_token": self.refresh_token
                }
                
                headers = {
                    "Content-Type": "application/x-www-form-urlencoded"
                }
                
                response = requests.post(
                    self.AUTH_URL, 
                    auth=auth,
                    data=payload,
                    headers=headers
                )
                
                if response.status_code == 200:
                    data = response.json()
                    self.access_token = data["access_token"]
                    if "refresh_token" in data:
                        self.refresh_token = data["refresh_token"]
                    expires_in = data.get("expires_in", 3600)
                    self.token_expires_at = datetime.now() + timedelta(seconds=expires_in - 60)
                    
                    self.logger.info(f"‚úÖ Token d'acc√®s rafra√Æchi avec succ√®s")
                    return True
                else:
                    self.logger.error(f"‚ùå √âchec du rafra√Æchissement du token: {response.status_code}")
                    self.logger.error(f"D√©tails: {response.text}")
                    return False
                    
            except Exception as e:
                self.logger.error(f"‚ùå Erreur lors du rafra√Æchissement du token: {str(e)}")
                return False
        else:
            # Si pas de refresh_token, on utilise le flux client credentials
            return self.get_access_token()
    
    def request_api(self, method: str, endpoint: str, data: Dict = None, params: Dict = None) -> Optional[Dict]:
        """
        Effectue une requ√™te √† l'API Sellsy v2.
        
        Args:
            method: M√©thode HTTP (GET, POST, PUT, DELETE)
            endpoint: Point de terminaison API (sans le pr√©fixe de base)
            data: Donn√©es √† envoyer (pour POST/PUT)
            params: Param√®tres de requ√™te (pour GET)
            
        Returns:
            R√©ponse de l'API ou None en cas d'erreur
        """
        try:
            # S'assurer que nous avons un token valide
            if self._is_token_expired():
                if not self.get_access_token():
                    self.logger.error("‚ùå Impossible d'obtenir un token d'acc√®s valide")
                    return None
            
            # Pr√©paration de l'URL
            url = f"{self.API_BASE_URL}/{endpoint.lstrip('/')}"
            
            # Pr√©paration des en-t√™tes
            headers = {
                "Authorization": f"Bearer {self.access_token}",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
            
            self.logger.debug(f"Requ√™te API v2: {method} {url}")
            if data:
                self.logger.debug(f"Donn√©es: {json.dumps(data)[:200]}...")
            if params:
                self.logger.debug(f"Param√®tres: {params}")
            
            # Ex√©cution de la requ√™te
            response = requests.request(
                method=method,
                url=url,
                headers=headers,
                json=data if data else None,
                params=params if params else None
            )
            
            # V√©rification du statut de la r√©ponse
            if response.status_code in [200, 201, 202, 204]:
                try:
                    if response.content:
                        result = response.json()
                        self.logger.debug(f"R√©ponse re√ßue: {json.dumps(result)[:200]}...")
                        return result
                    return {"status": "success"}
                except json.JSONDecodeError:
                    self.logger.error(f"‚ùå R√©ponse non-JSON: {response.text[:200]}")
                    return None
            elif response.status_code == 401:
                # Token expir√© ou invalide, on tente de rafra√Æchir
                self.logger.warning("‚ö†Ô∏è Token d'acc√®s expir√©. Tentative de rafra√Æchissement...")
                if self.refresh_access_token():
                    # On r√©essaie la requ√™te avec le nouveau token
                    return self.request_api(method, endpoint, data, params)
                return None
            else:
                self.logger.error(f"‚ùå Erreur HTTP: {response.status_code}")
                self.logger.error(f"D√©tails: {response.text}")
                return None
                
        except requests.RequestException as e:
            self.logger.error(f"‚ùå Erreur de connexion: {str(e)}")
            return None
        except Exception as e:
            self.logger.error(f"‚ùå Erreur inattendue: {str(e)}")
            self.logger.exception("D√©tails:")
            return None
    
    def test_authentication(self) -> bool:
        """
        Teste l'authentification en r√©cup√©rant les informations sur l'API.
        
        Returns:
            True si l'authentification est r√©ussie, False sinon
        """
        self.logger.info("üîÑ Test d'authentification Sellsy v2...")
        
        try:
            # R√©cup√©ration du compte utilisateur pour tester l'authentification
            response = self.request_api("GET", "/myself")
            
            if response:
                self.logger.info("‚úÖ Authentification r√©ussie!")
                return True
            else:
                self.logger.error("‚ùå √âchec d'authentification")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Erreur lors du test d'authentification: {str(e)}")
            return False
    
    def create_client(self, client_data: Dict) -> Optional[Dict]:
        """
        Cr√©e un nouveau client dans Sellsy.
        
        Args:
            client_data: Donn√©es du client √† cr√©er
            
        Returns:
            R√©ponse de l'API ou None en cas d'erreur
        """
        self.logger.info("üîÑ Cr√©ation d'un nouveau client dans Sellsy v2")
        
        try:
            # Conversion du format des donn√©es pour l'API v2
            v2_client_data = self._prepare_client_data_for_v2(client_data)
            
            # API v2 utilise diff√©rents endpoints pour individus et entreprises
            is_individual = client_data.get("third", {}).get("type") == "person"
            
            if is_individual:
                endpoint = "/individuals"
            else:
                endpoint = "/companies"
            
            # Ex√©cution de la requ√™te
            self.logger.debug(f"Donn√©es client format√©es pour v2: {v2_client_data}")
            response = self.request_api("POST", endpoint, v2_client_data)
            
            if response:
                # Extraction de l'ID client de la r√©ponse
                client_id = response.get("id")
                self.logger.info(f"‚úÖ Client cr√©√© avec succ√®s! ID: {client_id}")
                return {"status": "success", "response": client_id}
            else:
                self.logger.error("‚ùå √âchec de cr√©ation du client")
                return {"status": "error", "error": "√âchec de cr√©ation du client"}
                
        except Exception as e:
            self.logger.error(f"‚ùå Erreur lors de la cr√©ation du client: {str(e)}")
            self.logger.exception("D√©tails:")
            return {"status": "error", "error": str(e)}
    
    def _prepare_client_data_for_v2(self, old_data: Dict) -> Dict:
        """
        Convertit les donn√©es client du format v1 au format v2 attendu par l'API.
        
        Args:
            old_data: Donn√©es client au format v1
            
        Returns:
            Donn√©es client au format v2
        """
        # Extraction des donn√©es de l'ancien format
        third = old_data.get("third", {})
        contact = old_data.get("contact", {})
        address = old_data.get("address", {})
        
        # D√©terminer si c'est un particulier ou une entreprise
        is_individual = third.get("type") == "person"
        
        if is_individual:
            # Format pour les particuliers (individuals)
            result = {
                "first_name": contact.get("firstname", ""),
                "last_name": contact.get("name", ""),
                "email": contact.get("email", ""),
                "phone_number": contact.get("tel", ""),
                "civil": {
                    "civil": "mr" if contact.get("civility") == "man" else "mrs"
                },
                "addresses": []
            }
        else:
            # Format pour les entreprises (companies)
            result = {
                "name": third.get("name", ""),
                "email": third.get("email", ""),
                "phone_number": third.get("tel", ""),
                "note": third.get("notes", ""),
                "addresses": []
            }
        
        # Ajout de l'adresse si pr√©sente
        if address:
            new_address = {
                "name": address.get("name", "Adresse principale"),
                "address": address.get("part1", ""),
                "zip_code": address.get("zip", ""),
                "city": address.get("town", ""),
                "country_code": address.get("countrycode", "FR")
            }
            result["addresses"].append(new_address)
        
        # Ajout du contact pour les entreprises
        if not is_individual and contact:
            result["contacts"] = [{
                "first_name": contact.get("firstname", ""),
                "last_name": contact.get("name", ""),
                "email": contact.get("email", ""),
                "phone_number": contact.get("tel", "")
            }]
        
        return result
    
    def get_client(self, client_id: str, is_individual: bool = False) -> Optional[Dict]:
        """
        R√©cup√®re les informations d'un client par son ID.
        
        Args:
            client_id: ID du client √† r√©cup√©rer
            is_individual: True si le client est un particulier, False sinon
            
        Returns:
            Informations du client ou None en cas d'erreur
        """
        endpoint = f"/individuals/{client_id}" if is_individual else f"/companies/{client_id}"
        self.logger.info(f"üîÑ R√©cup√©ration du client ID: {client_id}")
        
        return self.request_api("GET", endpoint)
    
    def search_clients(self, search_term=None, limit=100) -> Optional[Dict]:
        """
        Recherche des clients dans Sellsy.
        
        Args:
            search_term: Terme de recherche (facultatif)
            limit: Nombre maximum de r√©sultats √† retourner
            
        Returns:
            Liste des clients ou None en cas d'erreur
        """
        self.logger.info(f"üîÑ Recherche de clients" + (f" avec terme: {search_term}" if search_term else ""))
        
        # Param√®tres de recherche
        params = {
            "limit": limit,
            "offset": 0
        }
        
        if search_term:
            params["search"] = search_term
        
        # Recherche dans les entreprises et particuliers
        companies = self.request_api("GET", "/companies", params=params) or {"data": []}
        individuals = self.request_api("GET", "/individuals", params=params) or {"data": []}
        
        # Combiner les r√©sultats
        results = []
        results.extend(companies.get("data", []))
        results.extend(individuals.get("data", []))
        
        return {"data": results[:limit]}
